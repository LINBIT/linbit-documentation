# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-03-02 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ==
#: benchmark.adoc:2
#, no-wrap
msgid "Measuring block device performance"
msgstr "测量块设备性能"

#. type: Title ===
#: benchmark.adoc:6
#, no-wrap
msgid "Measuring throughput"
msgstr "测量吞吐量"

#. type: Plain text
#: benchmark.adoc:13
msgid ""
"When measuring the impact of using DRBD on a system's I/O throughput, the "
"_absolute_ throughput the system is capable of is of little relevance. What "
"is much more interesting is the _relative_ impact DRBD has on I/O "
"performance. Thus it is always necessary to measure I/O throughput both with"
" and without DRBD."
msgstr ""
"当测量使用DRBD对系统I/O吞吐量的影响时，系统所能达到的绝对吞吐量几乎没有相关性。更有趣的是DRBD对I/O性能的相对影响。因此，无论有无DRBD，总是有必要测量I/O吞吐量。"

#. type: Plain text
#: benchmark.adoc:18
msgid ""
"The tests described in this section are intrusive; they overwrite data and "
"bring DRBD devices out of sync. It is thus vital that you perform them only "
"on scratch volumes which can be discarded after testing has completed."
msgstr "本节中描述的测试是侵入性的；它们覆盖数据并使DRBD设备失去同步。因此，只在测试完成后可以丢弃的暂存卷上执行它们是非常重要的。"

#. type: Plain text
#: benchmark.adoc:24
msgid ""
"I/O throughput estimation works by writing significantly large chunks of "
"data to a block device, and measuring the amount of time the system took to "
"complete the write operation. This can be easily done using a fairly "
"ubiquitous utility, `dd`, whose reasonably recent versions include a built-"
"in throughput estimation."
msgstr ""
"I/O吞吐量估计的工作原理是将大量数据写入块设备，并测量系统完成写入操作所需的时间。这可以使用相当普遍的实用程序 `dd` 轻松完成，该实用程序的最新版本包括内置的吞吐量估计。"

#. type: Plain text
#: benchmark.adoc:28
msgid ""
"A simple ``dd``-based throughput benchmark, assuming you have a scratch "
"resource named `test`, which is currently connected and in the secondary "
"role on both nodes, is one like the following:"
msgstr "一个简单的基于 `dd` 的吞吐量基准，假设您有一个名为 `test` 的临时资源，该资源当前已连接并且在两个节点上都处于次要角色，如下所示："

#. type: delimited block -
#: benchmark.adoc:42
#, no-wrap
msgid ""
"# TEST_RESOURCE=test\n"
"# TEST_DEVICE=$(drbdadm sh-dev $TEST_RESOURCE | head -1)\n"
"# TEST_LL_DEVICE=$(drbdadm sh-ll-dev $TEST_RESOURCE | head -1)\n"
"# drbdadm primary $TEST_RESOURCE\n"
"# for i in $(seq 5); do\n"
"    dd if=/dev/zero of=$TEST_DEVICE bs=1M count=512 oflag=direct\n"
"  done\n"
"# drbdadm down $TEST_RESOURCE\n"
"# for i in $(seq 5); do\n"
"    dd if=/dev/zero of=$TEST_LL_DEVICE bs=1M count=512 oflag=direct\n"
"  done\n"
msgstr ""
"# TEST_RESOURCE=test\n"
"# TEST_DEVICE=$(drbdadm sh-dev $TEST_RESOURCE | head -1)\n"
"# TEST_LL_DEVICE=$(drbdadm sh-ll-dev $TEST_RESOURCE | head -1)\n"
"# drbdadm primary $TEST_RESOURCE\n"
"# for i in $(seq 5); do\n"
"    dd if=/dev/zero of=$TEST_DEVICE bs=1M count=512 oflag=direct\n"
"  done\n"
"# drbdadm down $TEST_RESOURCE\n"
"# for i in $(seq 5); do\n"
"    dd if=/dev/zero of=$TEST_LL_DEVICE bs=1M count=512 oflag=direct\n"
"  done\n"

#. type: Plain text
#: benchmark.adoc:48
msgid ""
"This test simply writes 512MiB of data to your DRBD device, and then to its "
"backing device for comparison. Both tests are repeated 5 times each to allow"
" for some statistical averaging. The relevant result is the throughput "
"measurements generated by `dd`."
msgstr ""
"此测试只需将512MiB的数据写入DRBD设备，然后写入其备份设备进行比较。这两项测试各重复5次，以便进行一些统计平均。相关结果是由 `dd` 生成的吞吐量测量。"

#. type: Plain text
#: benchmark.adoc:52
msgid ""
"For freshly enabled DRBD devices, it is normal to see slightly reduced "
"performance on the first `dd` run. This is due to the Activity Log being "
"\"cold\", and is no cause for concern."
msgstr "对于刚刚启用的DRBD设备，在第一次 `dd` 运行时性能会略有下降是正常的。这是因为活动日志是 `冷` 的，不需要担心。"

#. type: Plain text
#: benchmark.adoc:54
msgid "See our <<ch-throughput>> chapter for some performance numbers."
msgstr "有关一些性能数据，请参阅我们的 <<ch-throughput>> 一章。"

#. type: Title ===
#: benchmark.adoc:57
#, no-wrap
msgid "Measuring latency"
msgstr "测量延迟"

#. type: Plain text
#: benchmark.adoc:65
msgid ""
"Latency measurements have objectives completely different from throughput "
"benchmarks: in I/O latency tests, one writes a very small chunk of data "
"(ideally the smallest chunk of data that the system can deal with), and "
"observes the time it takes to complete that write. The process is usually "
"repeated several times to account for normal statistical fluctuations."
msgstr ""
"延迟测量的目标与吞吐量基准完全不同：在I/O延迟测试中，一个人会写入非常小的数据块（理想情况下是系统可以处理的最小数据块），并观察完成该写入所需的时间。这个过程通常重复几次，以解释正常的统计波动。"

#. type: Plain text
#: benchmark.adoc:69
msgid ""
"Just as throughput measurements, I/O latency measurements may be performed "
"using the ubiquitous `dd` utility, albeit with different settings and an "
"entirely different focus of observation."
msgstr "与吞吐量测量一样，可以使用无处不在的 `dd` 实用程序执行I/O延迟测量，尽管设置不同，观察的焦点完全不同。"

#. type: Plain text
#: benchmark.adoc:73
msgid ""
"Provided below is a simple ``dd``-based latency micro-benchmark, assuming "
"you have a scratch resource named `test` which is currently connected and in"
" the secondary role on both nodes:"
msgstr ""
"下面提供了一个简单的基于 `dd` 的延迟微基准测试，假设您有一个名为 `test` 的临时资源，该资源当前已连接，并且在两个节点上都处于次要角色："

#. type: delimited block -
#: benchmark.adoc:83
#, no-wrap
msgid ""
"# TEST_RESOURCE=test\n"
"# TEST_DEVICE=$(drbdadm sh-dev $TEST_RESOURCE | head -1)\n"
"# TEST_LL_DEVICE=$(drbdadm sh-ll-dev $TEST_RESOURCE | head -1)\n"
"# drbdadm primary $TEST_RESOURCE\n"
"# dd if=/dev/zero of=$TEST_DEVICE bs=4k count=1000 oflag=direct\n"
"# drbdadm down $TEST_RESOURCE\n"
"# dd if=/dev/zero of=$TEST_LL_DEVICE bs=4k count=1000 oflag=direct\n"
msgstr ""
"# TEST_RESOURCE=test\n"
"# TEST_DEVICE=$(drbdadm sh-dev $TEST_RESOURCE | head -1)\n"
"# TEST_LL_DEVICE=$(drbdadm sh-ll-dev $TEST_RESOURCE | head -1)\n"
"# drbdadm primary $TEST_RESOURCE\n"
"# dd if=/dev/zero of=$TEST_DEVICE bs=4k count=1000 oflag=direct\n"
"# drbdadm down $TEST_RESOURCE\n"
"# dd if=/dev/zero of=$TEST_LL_DEVICE bs=4k count=1000 oflag=direct\n"

#. type: Plain text
#: benchmark.adoc:89
msgid ""
"This test writes 1,000 chunks with 4kiB each to your DRBD device, and then "
"to its backing device for comparison. 4096 bytes is the smallest block size "
"that a Linux system (on all architectures except s390), modern hard disks, "
"and SSDs, are expected to handle."
msgstr ""
"这个测试用4kiB分别将1000个数据块写入DRBD设备，然后写入其备份设备进行比较。4096字节是Linux系统（除了s390以外的所有体系结构）、现代硬盘和固态硬盘预计要处理的最小块大小。"

#. type: Plain text
#: benchmark.adoc:94
msgid ""
"It is important to understand that throughput measurements generated by `dd`"
" are completely irrelevant for this test; what is important is the _time_ "
"elapsed during the completion of said 1,000 writes. Dividing this time by "
"1,000 gives the average latency of a single block write."
msgstr ""
"重要的是要了解由 `dd` 生成的吞吐量测量与此测试完全无关；重要的是在完成所述1000次写入过程中经过的时间。将此时间除以1000可得出单个块写入的平均延迟。"

#. type: Plain text
#: benchmark.adoc:98
msgid ""
"This is the _worst-case_, in that it is single-threaded and does one write "
"strictly after the one before, ie. runs with an I/O-depth of 1. Please take "
"a look at <<s-latency-iops>>."
msgstr ""
"这是最坏的情况，因为它是单线程的，并且在之前的一个之后严格执行一个写操作，即I/O深度为1的运行。请查看<<s-latency-iops>>。"

#. type: Plain text
#: benchmark.adoc:100
msgid ""
"Furthermore, see our <<ch-latency>> chapter for some typical performance "
"values."
msgstr "此外，有关一些典型的性能值，请参阅我们的<<ch-latency>>一章。"
