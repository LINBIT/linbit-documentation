# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2020-03-02 15:09+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ==
#: lvm.adoc:2
#, no-wrap
msgid "Using LVM with DRBD"
msgstr "在DRBD中使用LVM"

#. type: Plain text
#: lvm.adoc:6
msgid ""
"indexterm:[LVM]indexterm:[Logical Volume Management]This chapter deals with "
"managing DRBD in conjunction with LVM2. In particular, it covers"
msgstr ""
"indexterm:[LVM]indexterm:[Logical Volume "
"Management]本章讨论如何结合LVM2管理DRBD。特别是，它包括"

#. type: Plain text
#: lvm.adoc:8
msgid "using LVM Logical Volumes as backing devices for DRBD;"
msgstr "使用LVM逻辑卷作为DRBD的备份设备；"

#. type: Plain text
#: lvm.adoc:10
msgid "using DRBD devices as Physical Volumes for LVM;"
msgstr "使用DRBD设备作为LVM的物理卷；"

#. type: Plain text
#: lvm.adoc:13
msgid ""
"combining these to concepts to implement a layered LVM approach using DRBD."
msgstr "结合这些概念，使用DRBD实现分层LVM方法。"

#. type: Plain text
#: lvm.adoc:18
msgid ""
"If you happen to be unfamiliar with these terms to begin with, <<s-lvm-"
"primer>> may serve as your LVM starting point -- although you are always "
"encouraged, of course, to familiarize yourself with LVM in some more detail "
"than this section provides."
msgstr ""
"如果您碰巧不熟悉这些术语，那么<<s-lvm-primer>>可以作为您的lvm起点 - 当然，我们始终鼓励您在本节提供的更多细节中熟悉lvm。"

#. type: Title ===
#: lvm.adoc:20
#, no-wrap
msgid "LVM primer"
msgstr "LVM基础"

#. type: Plain text
#: lvm.adoc:27
msgid ""
"LVM2 is an implementation of logical volume management in the context of the"
" Linux device mapper framework. It has practically nothing in common, other "
"than the name and acronym, with the original LVM implementation. The old "
"implementation (now retroactively named \"LVM1\") is considered obsolete; it"
" is not covered in this section."
msgstr ""
"LVM2是Linux device mapper框架上下文中逻辑卷管理的实现。它实际上与原始LVM实现没有任何共同点，除了名称和缩写。旧的实现（现在追溯命名为 \"LVM1\"）被认为是过时的；本节不涉及它。"

#. type: Plain text
#: lvm.adoc:30
msgid ""
"When working with LVM, it is important to understand its most basic "
"concepts:"
msgstr "在使用LVM时，必须了解其最基本的概念："

#. type: Block title
#: lvm.adoc:32
#, no-wrap
msgid "Physical Volume (PV)"
msgstr "物理卷（PV）"

#. type: Plain text
#: lvm.adoc:38
msgid ""
"indexterm:[LVM]indexterm:[Physical Volume (LVM)]A PV is an underlying block "
"device exclusively managed by LVM. PVs can either be entire hard disks or "
"individual partitions. It is common practice to create a partition table on "
"the hard disk where one partition is dedicated to the use by the Linux LVM."
msgstr ""
"indexterm:[LVM]indexterm:[Physical "
"Volume（LVM）]PV是由LVM独占管理的底层块设备。pv可以是整个硬盘，也可以是单独的分区。通常的做法是在硬盘上创建一个分区表，其中一个分区专用于Linux"
" LVM的使用。"

#. type: Plain text
#: lvm.adoc:43
msgid ""
"The partition type \"Linux LVM\" (signature `0x8E`) can be used to identify "
"partitions for exclusive use by LVM. This, however, is not required -- LVM "
"recognizes PVs by way of a signature written to the device upon PV "
"initialization."
msgstr ""
"分区类型 \"Linux "
"LVM\"（签名 `0x8E`）可用于标识供LVM独占使用的分区。然而，这并不是必需的 - LVM通过在PV初始化时写入设备的签名来识别PV。"

#. type: Block title
#: lvm.adoc:44
#, no-wrap
msgid "Volume Group (VG)"
msgstr "卷组（VG）"

#. type: Plain text
#: lvm.adoc:49
msgid ""
"indexterm:[LVM]indexterm:[Volume Group (LVM)]A VG is the basic "
"administrative unit of the LVM. A VG may include one or more several PVs. "
"Every VG has a unique name. A VG may be extended during runtime by adding "
"additional PVs, or by enlarging an existing PV."
msgstr ""
"indexterm:[LVM]indexterm:[Volume "
"Group（LVM）]VG是LVM的基本管理单元。VG可以包括一个或多个pv。每个VG都有一个唯一的名称。VG可以在运行时通过添加额外的PV或通过扩大现有的PV来扩展。"

#. type: Block title
#: lvm.adoc:50
#, no-wrap
msgid "Logical Volume (LV)"
msgstr "逻辑卷（LV）"

#. type: Plain text
#: lvm.adoc:58
msgid ""
"indexterm:[LVM]indexterm:[Logical Volume (LVM)]LVs may be created during "
"runtime within VGs and are available to the other parts of the kernel as "
"regular block devices. As such, they may be used to hold a file system, or "
"for any other purpose block devices may be used for. LVs may be resized "
"while they are online, and they may also be moved from one PV to another (as"
" long as the PVs are part of the same VG)."
msgstr ""
"indexterm:[LVM]indexterm:[Logical "
"Volume（LVM）]LVs可以在VGs中的运行时创建，并且可以作为常规块设备供内核的其他部分使用。因此，它们可用于保存文件系统，或用于任何其他目的，块设备可用于。LVs可以在联机时调整大小，也可以从一个PV移动到另一个PV（只要PV是同一VG的一部分）。"

#. type: Block title
#: lvm.adoc:59
#, no-wrap
msgid "Snapshot Logical Volume (SLV)"
msgstr "快照逻辑卷（SLV）"

#. type: Plain text
#: lvm.adoc:65
msgid ""
"indexterm:[snapshots (LVM)]indexterm:[LVM]Snapshots are temporary point-in-"
"time copies of LVs. Creating snapshots is an operation that completes almost"
" instantly, even if the original LV (the _origin volume_) has a size of "
"several hundred GiByte. Usually, a snapshot requires significantly less "
"space than the original LV."
msgstr ""
"indexterm:[snapshots（LVM）]indexterm:[LVM]快照是LVs的临时时间点副本。创建快照是一个几乎立即完成的操作，即使原始LV（原始卷）的大小为几百吉比特。通常，快照需要的空间比原始LV少得多。"

#. type: Block title
#: lvm.adoc:67
#, no-wrap
msgid "LVM overview"
msgstr "LVM概述"

#. type: Target for macro image
#: lvm.adoc:68
#, no-wrap
msgid "images/lvm.svg"
msgstr "images/lvm.svg"

#. type: Title ===
#: lvm.adoc:72
#, no-wrap
msgid "Using a Logical Volume as a DRBD backing device"
msgstr "使用逻辑卷作为DRBD备份设备"

#. type: Plain text
#: lvm.adoc:79
msgid ""
"indexterm:[LVM]indexterm:[Logical Volume (LVM)]Since an existing Logical "
"Volume is simply a block device in Linux terms, you may of course use it as "
"a DRBD backing device. To use LV's in this manner, you simply create them, "
"and then initialize them for DRBD as you normally would."
msgstr ""
"indexterm:[LVM]indexterm:[Logical "
"Volume（LVM）]要以这种方式使用LV，只需创建它们，然后像通常那样为DRBD初始化它们。"

#. type: Plain text
#: lvm.adoc:84
msgid ""
"This example assumes that a Volume Group named `foo` already exists on both "
"nodes of on your LVM-enabled system, and that you wish to create a DRBD "
"resource named `r0` using a Logical Volume in that Volume Group."
msgstr "此示例假设在启用LVM的系统上的两个节点上都已存在名为 `foo` 的卷组，并且您希望使用该卷组中的逻辑卷创建名为 `r0` 的DRBD资源。"

#. type: Plain text
#: lvm.adoc:87
msgid ""
"First, you create the Logical Volume: indexterm:[LVM]indexterm:[lvcreate "
"(LVM command)]"
msgstr "首先，创建逻辑卷：indexterm:[LVM]indexterm:[lvcreate (LVM command)]"

#. type: delimited block -
#: lvm.adoc:90
#, no-wrap
msgid ""
"# lvcreate --name bar --size 10G foo\n"
"Logical volume \"bar\" created\n"
msgstr ""
"# lvcreate --name bar --size 10G foo\n"
"Logical volume \"bar\" created\n"

#. type: Plain text
#: lvm.adoc:95
msgid ""
"Of course, you must complete this command on both nodes of your DRBD "
"cluster. After this, you should have a block device named `/dev/foo/bar` on "
"either node."
msgstr "当然，您必须在DRBD集群的两个节点上完成此命令。之后，在任一节点上都应该有一个名为 `/dev/foo/bar` 的块设备。"

#. type: Plain text
#: lvm.adoc:98
msgid ""
"Then, you can simply enter the newly-created volumes in your resource "
"configuration:"
msgstr "然后，只需在资源配置中输入新创建的卷："

#. type: delimited block -
#: lvm.adoc:114
#, no-wrap
msgid ""
"resource r0 {\n"
"  ...\n"
"  on alice {\n"
"    device /dev/drbd0;\n"
"    disk   /dev/foo/bar;\n"
"    ...\n"
"  }\n"
"  on bob {\n"
"    device /dev/drbd0;\n"
"    disk   /dev/foo/bar;\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""
"resource r0 {\n"
"  ...\n"
"  on alice {\n"
"    device /dev/drbd0;\n"
"    disk   /dev/foo/bar;\n"
"    ...\n"
"  }\n"
"  on bob {\n"
"    device /dev/drbd0;\n"
"    disk   /dev/foo/bar;\n"
"    ...\n"
"  }\n"
"}\n"

#. type: Plain text
#: lvm.adoc:118
msgid ""
"Now you can <<s-first-time-up,continue to bring your resource up>>, just as "
"you would if you were using non-LVM block devices."
msgstr ""
"现在您可以<<s-first-time-up,continue to bring your resource up>>，就像使用非LVM块设备一样。"

#. type: Title ===
#: lvm.adoc:120
#, no-wrap
msgid "Using automated LVM snapshots during DRBD synchronization"
msgstr "在DRBD同步期间使用自动LVM快照"

#. type: Plain text
#: lvm.adoc:127
msgid ""
"While DRBD is synchronizing, the __SyncTarget__'s state is _Inconsistent_ "
"until the synchronization completes. If in this situation the _SyncSource_ "
"happens to fail (beyond repair), this puts you in an unfortunate position: "
"the node with good data is dead, and the surviving node has bad "
"(inconsistent) data."
msgstr ""
"当DRBD正在同步时，同步目标的状态是不一致的，直到同步完成。如果在这种情况下，SyncSource发生故障（无法修复），这将使您处于一个不幸的位置：具有良好数据的节点已死亡，而幸存的节点具有不良（不一致）数据。"

#. type: Plain text
#: lvm.adoc:132
msgid ""
"When serving DRBD off an LVM Logical Volume, you can mitigate this problem "
"by creating an automated snapshot when synchronization starts, and "
"automatically removing that same snapshot once synchronization has completed"
" successfully."
msgstr "当从LVM逻辑卷上服务DRBD时，可以通过在同步启动时创建自动快照，并在同步成功完成后自动删除同一快照来缓解此问题。"

#. type: Plain text
#: lvm.adoc:135
msgid ""
"In order to enable automated snapshotting during resynchronization, add the "
"following lines to your resource configuration:"
msgstr "为了在重新同步期间启用自动快照，请在资源配置中添加以下行："

#. type: Block title
#: lvm.adoc:136
#, no-wrap
msgid "Automating snapshots before DRBD synchronization"
msgstr "在DRBD同步之前自动生成快照"

#. type: delimited block -
#: lvm.adoc:144
#, no-wrap
msgid ""
"resource r0 {\n"
"  handlers {\n"
"    before-resync-target \"/usr/lib/drbd/snapshot-resync-target-lvm.sh\";\n"
"    after-resync-target \"/usr/lib/drbd/unsnapshot-resync-target-lvm.sh\";\n"
"  }\n"
"}\n"
msgstr ""
"resource r0 {\n"
"  handlers {\n"
"    before-resync-target \"/usr/lib/drbd/snapshot-resync-target-lvm.sh\";\n"
"    after-resync-target \"/usr/lib/drbd/unsnapshot-resync-target-lvm.sh\";\n"
"  }\n"
"}\n"

#. type: Plain text
#: lvm.adoc:152
msgid ""
"The two scripts parse the `$DRBD_RESOURCE` environment variable which DRBD "
"automatically passes to any `handler` it invokes. The `snapshot-resync-"
"target-lvm.sh` script then creates an LVM snapshot for any volume the "
"resource contains, then synchronization kicks off. In case the script fails,"
" the synchronization _does not commence_."
msgstr ""
"这两个脚本解析DRBD自动传递给它调用的任何 `handler` 的 `$DRBD_RESOURCE` 环境变量。然后， `snapshot-resync-"
"target-lvm.sh` 脚本为资源包含的任何卷创建一个lvm快照，然后开始同步。如果脚本失败，则同步不会开始。"

#. type: Plain text
#: lvm.adoc:156
msgid ""
"Once synchronization completes, the `unsnapshot-resync-target-lvm.sh` script"
" removes the snapshot, which is then no longer needed. In case "
"unsnapshotting fails, the snapshot continues to linger around."
msgstr "同步完成后， `unsnapshot-resync-target-lvm.sh` 脚本将删除不再需要的快照。如果取消快照失败，快照将继续徘徊。"

#. type: Plain text
#: lvm.adoc:160
msgid ""
"You should review dangling snapshots as soon as possible. A full snapshot "
"causes both the snapshot itself _and its origin volume_ to fail."
msgstr "你应该尽快检查悬挂的快照。完整快照会导致快照本身及其原始卷失败。"

#. type: Plain text
#: lvm.adoc:164
msgid ""
"If at any time your _SyncSource_ does fail beyond repair and you decide to "
"revert to your latest snapshot on the peer, you may do so by issuing the "
"`lvconvert -M` command."
msgstr ""
"如果您的同步源在任何时候确实出现无法修复的故障，并且您决定还原到对等机上的最新快照，则可以通过输入 `lvconvert -M` 命令来执行此操作。"

#. type: Title ===
#: lvm.adoc:166
#, no-wrap
msgid "Configuring a DRBD resource as a Physical Volume"
msgstr "将DRBD资源配置为物理卷"

#. type: Plain text
#: lvm.adoc:173
msgid ""
"indexterm:[LVM]indexterm:[Physical Volume (LVM)]In order to prepare a DRBD "
"resource for use as a Physical Volume, it is necessary to create a PV "
"signature on the DRBD device. In order to do so, issue one of the following "
"commands on the node where the resource is currently in the primary role: "
"indexterm:[LVM]indexterm:[pvcreate (LVM command)]"
msgstr ""
"indexterm:[LVM]indexterm:[Physical "
"Volume (LVM)]。为此，请在资源当前处于主要角色的节点上发出以下命令之一：indexterm:[LVM]indexterm:[pvcreate (LVM command)]"

#. type: delimited block -
#: lvm.adoc:176
#, no-wrap
msgid "# pvcreate /dev/drbdX\n"
msgstr "# pvcreate /dev/drbdX\n"

#. type: Plain text
#: lvm.adoc:179
msgid "or"
msgstr "或"

#. type: delimited block -
#: lvm.adoc:182
#, no-wrap
msgid "# pvcreate /dev/drbd/by-res/<resource>/0\n"
msgstr "# pvcreate /dev/drbd/by-res/<resource>/0\n"

#. type: Plain text
#: lvm.adoc:185
msgid "This example assumes a single-volume resource."
msgstr "本例假设一个含有单个卷的资源。"

#. type: Plain text
#: lvm.adoc:194
msgid ""
"Now, it is necessary to include this device in the list of devices LVM scans"
" for PV signatures. In order to do this, you must edit the LVM configuration"
" file, normally named indexterm:[LVM]`/etc/lvm/lvm.conf`. Find the line in "
"the `devices` section that contains the `filter` keyword and edit it "
"accordingly. If _all_ your PVs are to be stored on DRBD devices, the "
"following is an appropriate `filter` option: "
"indexterm:[LVM]indexterm:[filter expression (LVM)]"
msgstr ""
"现在，有必要将这个设备包含在LVM扫描PV签名的设备列表中。为此，必须编辑LVM配置文件，通常命名为indexterm:[LVM]`/etc/LVM/LVM.conf`。在 `devices` 部分找到包含 `filter` 关键字的行，并相应地对其进行编辑。如果要将所有pv存储在DRBD设备上，则以下是适当的 `filter` 选项：indexterm:[LVM]indexterm:[filter"
" expression（LVM）]"

#. type: delimited block -
#: lvm.adoc:198
#, no-wrap
msgid "filter = [ \"a|drbd.*|\", \"r|.*|\" ]\n"
msgstr "filter = [ \"a|drbd.*|\", \"r|.*|\" ]\n"

#. type: Plain text
#: lvm.adoc:202
msgid ""
"This filter expression accepts PV signatures found on any DRBD devices, "
"while rejecting (ignoring) all others."
msgstr "此筛选器表达式接受在任何DRBD设备上找到的PV签名，同时拒绝（忽略）所有其他签名。"

#. type: Plain text
#: lvm.adoc:205
msgid ""
"By default, LVM scans all block devices found in `/dev` for PV signatures. "
"This is equivalent to `filter = [ \"a|.*|\" ]`."
msgstr "默认情况下，LVM扫描在 `/dev` 中找到的所有块设备以获取PV签名。这相当于 `filter=[ \"a |.*|\" ]`。"

#. type: Plain text
#: lvm.adoc:213
msgid ""
"If you want to use stacked resources as LVM PVs, then you will need a more "
"explicit filter configuration. You need to make sure that LVM detects PV "
"signatures on stacked resources, while ignoring them on the corresponding "
"lower-level resources and backing devices. This example assumes that your "
"lower-level DRBD resources use device minors 0 through 9, whereas your "
"stacked resources are using device minors from 10 upwards:"
msgstr ""
"如果要将堆叠资源用作LVM "
"pv，则需要更明确的筛选器配置。您需要确保LVM在堆栈资源上检测到PV签名，而在相应的低级资源和备份设备上忽略它们。此示例假设较低级别的DRBD资源使用设备子级0到9，而堆叠的资源使用的设备子级从10到9："

#. type: delimited block -
#: lvm.adoc:217
#, no-wrap
msgid "filter = [ \"a|drbd1[0-9]|\", \"r|.*|\" ]\n"
msgstr "filter = [ \"a|drbd1[0-9]|\", \"r|.*|\" ]\n"

#. type: Plain text
#: lvm.adoc:222
msgid ""
"This filter expression accepts PV signatures found only on the DRBD devices "
"`/dev/drbd10` through `/dev/drbd19`, while rejecting (ignoring) all others."
msgstr "此筛选器表达式接受仅在DRBD设备 `/dev/drbd10` 到 `/dev/drbd19' 上找到的PV签名，同时拒绝（忽略）所有其他签名。"

#. type: Plain text
#: lvm.adoc:227 lvm.adoc:374
msgid ""
"After modifying the `lvm.conf` file, you must run the "
"indexterm:[LVM]indexterm:[vgscan (LVM command)]`vgscan` command so LVM "
"discards its configuration cache and re-scans devices for PV signatures."
msgstr ""
"修改 `lvm.conf` 文件后，必须运行indexterm:[lvm]indexterm:[vgscan（lvm "
"command）] `vgscan` 命令，以便lvm放弃其配置缓存并重新扫描设备以获取PV签名。"

#. type: Plain text
#: lvm.adoc:231
msgid ""
"You may of course use a different `filter` configuration to match your "
"particular system configuration. What is important to remember, however, is "
"that you need to"
msgstr "当然，您可以使用不同的 `filter` 配置来匹配您的特定系统配置。然而，重要的是要记住，你需要"

#. type: Plain text
#: lvm.adoc:233
msgid "Accept (include) the DRBD devices you wish to use as PVs;"
msgstr "接受（包括）您希望用作pv的DRBD设备；"

#. type: Plain text
#: lvm.adoc:235
msgid ""
"Reject (exclude) the corresponding lower-level devices, so as to avoid LVM "
"finding duplicate PV signatures."
msgstr "拒绝（排除）相应的低级设备，以避免LVM发现重复的PV签名。"

#. type: Plain text
#: lvm.adoc:237
msgid "In addition, you should disable the LVM cache by setting:"
msgstr "此外，应通过设置以下内容禁用LVM缓存："

#. type: delimited block -
#: lvm.adoc:241 lvm.adoc:383
#, no-wrap
msgid "write_cache_state = 0\n"
msgstr "write_cache_state = 0\n"

#. type: Plain text
#: lvm.adoc:245 lvm.adoc:387
msgid ""
"After disabling the LVM cache, make sure you remove any stale cache entries "
"by deleting `/etc/lvm/cache/.cache`."
msgstr "禁用LVM缓存后，请确保通过删除 `/etc/LVM/cache/.cache` ，删除所有过时的缓存条目。"

#. type: Plain text
#: lvm.adoc:247
msgid "You must repeat the above steps on the peer nodes, too."
msgstr "您还必须在对等节点上重复上述步骤。"

#. type: Plain text
#: lvm.adoc:255
msgid ""
"If your system has its root filesystem on LVM, Volume Groups will be "
"activated from your initial ramdisk (initrd) during boot. In doing so, the "
"LVM tools will evaluate an `lvm.conf` file included in the initrd image. "
"Thus, after you make any changes to your `lvm.conf`, you should be certain "
"to update your initrd with the utility appropriate for your distribution "
"(`mkinitrd`, `update-initramfs` etc.)."
msgstr ""
"如果系统的根文件系统位于LVM上，则卷组将在引导期间从初始ramdisk（initrd）激活。"
"这样，LVM工具将计算initrd映像中包含的 `LVM.conf` 文件。因此，"
"在对 `lvm.conf` 进行任何更改之后，您应该确定使用适合您"
"的发行版的实用程序（ `mkinitrd` 、`update-"
"initramfs` 等）更新initrd。"

#. type: Plain text
#: lvm.adoc:260
msgid ""
"When you have configured your new PV, you may proceed to add it to a Volume "
"Group, or create a new Volume Group from it. The DRBD resource must, of "
"course, be in the primary role while doing so. "
"indexterm:[LVM]indexterm:[vgcreate (LVM command)]"
msgstr ""
"配置新的PV后，可以继续将其添加到卷组，或从中创建新的卷组。"
"当然，DRBD资源在执行此操作时必须处于主要角色。indexterm:[LVM]indexterm:[vgcreate（LVM command）]"

#. type: delimited block -
#: lvm.adoc:263
#, no-wrap
msgid "# vgcreate <name> /dev/drbdX\n"
msgstr "# vgcreate <name> /dev/drbdX\n"

#. type: Plain text
#: lvm.adoc:268
msgid ""
"While it is possible to mix DRBD and non-DRBD Physical Volumes within the "
"same Volume Group, doing so is not recommended and unlikely to be of any "
"practical value."
msgstr "虽然可以在同一个卷组中混合DRBD和非DRBD物理卷，但不建议这样做，也不太可能有任何实际价值。"

#. type: Plain text
#: lvm.adoc:272
msgid ""
"When you have created your VG, you may start carving Logical Volumes out of "
"it, using the indexterm:[LVM]indexterm:[lvcreate (LVM command)]`lvcreate` "
"command (as with a non-DRBD-backed Volume Group)."
msgstr ""
"创建VG后，可以使用indexterm:[LVM]indexterm:[lvcreate（LVM "
"command）] `lvcreate` 命令（与非DRBD支持的卷组一样）开始从中切分逻辑卷。"

#. type: Title ===
#: lvm.adoc:274
#, no-wrap
msgid "Adding a new DRBD volume to an existing Volume Group"
msgstr "将新的DRBD卷添加到现有卷组"

#. type: Plain text
#: lvm.adoc:280
msgid ""
"Occasionally, you may want to add new DRBD-backed Physical Volumes to a "
"Volume Group. Whenever you do so, a new volume should be added to an "
"existing resource configuration. This preserves the replication stream and "
"ensures write fidelity across all PVs in the VG."
msgstr ""
"有时，您可能希望向卷组中添加新的DRBD支持的物理卷。无论何时执行此操作，都应将新卷添加到现有资源配置中。这将保留复制流并确保VG中所有pv的写入保真度。"

#. type: Plain text
#: lvm.adoc:285
msgid ""
"if your LVM volume group is managed by Pacemaker as explained in <<s-lvm-"
"pacemaker>>, it is _imperative_ to place the cluster in maintenance mode "
"prior to making changes to the DRBD configuration."
msgstr "如果您的LVM卷组由Pacemaker管理，如<<s-lvm-pacemaker>>中所述，则在更改DRBD配置之前，必须将集群置于维护模式。"

#. type: Plain text
#: lvm.adoc:288
msgid ""
"Extend your resource configuration to include an additional volume, as in "
"the following example:"
msgstr "扩展资源配置以包括附加卷，如下例所示："

#. type: delimited block -
#: lvm.adoc:308
#, no-wrap
msgid ""
"resource r0 {\n"
"  volume 0 {\n"
"    device    /dev/drbd1;\n"
"    disk      /dev/sda7;\n"
"    meta-disk internal;\n"
"  }\n"
"  volume 1 {\n"
"    device    /dev/drbd2;\n"
"    disk      /dev/sda8;\n"
"    meta-disk internal;\n"
"  }\n"
"  on alice {\n"
"    address   10.1.1.31:7789;\n"
"  }\n"
"  on bob {\n"
"    address   10.1.1.32:7789;\n"
"  }\n"
"}\n"
msgstr ""
"resource r0 {\n"
"  volume 0 {\n"
"    device    /dev/drbd1;\n"
"    disk      /dev/sda7;\n"
"    meta-disk internal;\n"
"  }\n"
"  volume 1 {\n"
"    device    /dev/drbd2;\n"
"    disk      /dev/sda8;\n"
"    meta-disk internal;\n"
"  }\n"
"  on alice {\n"
"    address   10.1.1.31:7789;\n"
"  }\n"
"  on bob {\n"
"    address   10.1.1.32:7789;\n"
"  }\n"
"}\n"

#. type: Plain text
#: lvm.adoc:312
msgid ""
"Make sure your DRBD configuration is identical across nodes, then issue:"
msgstr "确保您的DRBD配置在节点间是相同的，然后输入："

#. type: delimited block -
#: lvm.adoc:315
#, no-wrap
msgid "# drbdadm adjust r0\n"
msgstr "# drbdadm adjust r0\n"

#. type: Plain text
#: lvm.adoc:320
msgid ""
"This will implicitly call `drbdsetup new-minor r0 1` to enable the new "
"volume `1` in the resource `r0`. Once the new volume has been added to the "
"replication stream, you may initialize and add it to the volume group:"
msgstr ""
"这将隐式调用 `drbdsetup new-minor r0 1`，以启用资源 `r0` 中的新卷 `1`。将新卷添加到复制流后，可以初始化并将其添加到卷组："

#. type: delimited block -
#: lvm.adoc:324
#, no-wrap
msgid ""
"# pvcreate /dev/drbd/by-res/<resource>/1\n"
"# vgextend <name> /dev/drbd/by-res/<resource>/1\n"
msgstr ""
"# pvcreate /dev/drbd/by-res/<resource>/1\n"
"# vgextend <name> /dev/drbd/by-res/<resource>/1\n"

#. type: Plain text
#: lvm.adoc:328
msgid ""
"This will add the new PV `/dev/drbd/by-res/<resource>/1` to the `<name>` VG,"
" preserving write fidelity across the entire VG."
msgstr "这将把新的PV `/dev/drbd/by res/<resource>/1` 添加到 `<name>` VG中，从而在整个VG中保持写保真度。"

#. type: Title ===
#: lvm.adoc:331
#, no-wrap
msgid "Nested LVM configuration with DRBD"
msgstr "带DRBD的嵌套LVM配置"

#. type: Plain text
#: lvm.adoc:338
msgid ""
"It is possible, if slightly advanced, to both use "
"indexterm:[LVM]indexterm:[Logical Volume (LVM)]Logical Volumes as backing "
"devices for DRBD _and_ at the same time use a DRBD device itself as a "
"indexterm:[LVM]indexterm:[Physical Volume (LVM)]Physical Volume. To provide "
"an example, consider the following configuration:"
msgstr ""
"如果稍微高级一点，可以同时使用indexterm:[LVM]indexterm:[Logical Volume（LVM）]Logical "
"Volumes作为DRBD的备份设备，同时使用DRBD设备本身作为indexterm:[LVM]indexterm:[Physical "
"Volume（LVM）]Physical Volume。要提供示例，请考虑以下配置："

#. type: Plain text
#: lvm.adoc:341
msgid ""
"We have two partitions, named `/dev/sda1`, and `/dev/sdb1`, which we intend "
"to use as Physical Volumes."
msgstr "我们有两个分区，名为 `/dev/sda1` ，和 `/dev/sdb1` ，打算用作物理卷。"

#. type: Plain text
#: lvm.adoc:344
msgid "Both of these PVs are to become part of a Volume Group named `local`."
msgstr "这两个pv都将成为名为 `local` 的卷组的一部分。"

#. type: Plain text
#: lvm.adoc:346
msgid ""
"We want to create a 10-GiB Logical Volume in this VG, to be named `r0`."
msgstr "我们想在这个VG中创建一个10 GiB的逻辑卷，名为 `r0`。"

#. type: Plain text
#: lvm.adoc:349
msgid ""
"This LV will become the local backing device for our DRBD resource, also "
"named `r0`, which corresponds to the device `/dev/drbd0`."
msgstr "这个LV将成为DRBD资源的本地备份设备，也称为 `r0`，它对应于设备 `/dev/drbd0`。"

#. type: Plain text
#: lvm.adoc:352
msgid ""
"This device will be the sole PV for another Volume Group, named "
"`replicated`."
msgstr "此设备将是另一个名为 `replicated` 的卷组的唯一PV。"

#. type: Plain text
#: lvm.adoc:355
msgid ""
"This VG is to contain two more logical volumes named `foo`(4 GiB)  and "
"`bar`(6 GiB)."
msgstr "这个VG将包含另外两个名为 `foo`（4 GiB）和 `bar`（6 GiB）的逻辑卷。"

#. type: Plain text
#: lvm.adoc:357
msgid "In order to enable this configuration, follow these steps:"
msgstr "要启用此配置，请执行以下步骤："

#. type: Plain text
#: lvm.adoc:359
msgid "Set an appropriate `filter` option in your `/etc/lvm/lvm.conf`:"
msgstr "在 `/etc/lvm/lvm.conf` 中设置适当的 `filter` 选项："

#. type: Plain text
#: lvm.adoc:362
msgid "indexterm:[LVM]indexterm:[filter expression (LVM)]"
msgstr "indexterm:[LVM]indexterm:[filter expression (LVM)]"

#. type: delimited block -
#: lvm.adoc:365
#, no-wrap
msgid "filter = [\"a|sd.*|\", \"a|drbd.*|\", \"r|.*|\"]\n"
msgstr "filter = [\"a|sd.*|\", \"a|drbd.*|\", \"r|.*|\"]\n"

#. type: Plain text
#: lvm.adoc:369
msgid ""
"This filter expression accepts PV signatures found on any SCSI and DRBD "
"devices, while rejecting (ignoring) all others."
msgstr "这个过滤器表达式接受在任何SCSI和DRBD设备上找到的PV签名，同时拒绝（忽略）所有其他的。"

#. type: Plain text
#: lvm.adoc:378
msgid "Disable the LVM cache by setting:"
msgstr "通过设置禁用LVM缓存："

#. type: Plain text
#: lvm.adoc:391
msgid ""
"Now, you may initialize your two SCSI partitions as PVs: "
"indexterm:[LVM]indexterm:[pvcreate (LVM command)]"
msgstr "现在，您可以将两个SCSI分区初始化为PVs:indexterm:[LVM]indexterm:[pvcreate(LVM command)]"

#. type: delimited block -
#: lvm.adoc:398
#, no-wrap
msgid ""
"# pvcreate /dev/sda1\n"
"Physical volume \"/dev/sda1\" successfully created\n"
"# pvcreate /dev/sdb1\n"
"Physical volume \"/dev/sdb1\" successfully created\n"
msgstr ""
"# pvcreate /dev/sda1\n"
"Physical volume \"/dev/sda1\" successfully created\n"
"# pvcreate /dev/sdb1\n"
"Physical volume \"/dev/sdb1\" successfully created\n"

#. type: Plain text
#: lvm.adoc:405
msgid ""
"The next step is creating your low-level VG named `local`, consisting of the"
" two PVs you just initialized: indexterm:[LVM]indexterm:[vgcreate (LVM "
"command)]"
msgstr ""
"下一步是创建名为 `local` 的低级VG，它由刚刚初始化的两个pv组成：indexterm:[LVM]indexterm:[vgcreate (LVM command)]"

#. type: delimited block -
#: lvm.adoc:409
#, no-wrap
msgid ""
"# vgcreate local /dev/sda1 /dev/sda2\n"
"Volume group \"local\" successfully created\n"
msgstr ""
"# vgcreate local /dev/sda1 /dev/sda2\n"
"Volume group \"local\" successfully created\n"

#. type: Plain text
#: lvm.adoc:413
msgid ""
"Now you may create your Logical Volume to be used as DRBD's backing device: "
"indexterm:[LVM]indexterm:[lvcreate (LVM command)]"
msgstr "现在您可以创建用作DRBD的备份设备的逻辑卷：indexterm:[LVM]indexterm:[lvcreate (LVM command)]"

#. type: delimited block -
#: lvm.adoc:417
#, no-wrap
msgid ""
"# lvcreate --name r0 --size 10G local\n"
"Logical volume \"r0\" created\n"
msgstr ""
"# lvcreate --name r0 --size 10G local\n"
"Logical volume \"r0\" created\n"

#. type: Plain text
#: lvm.adoc:420
msgid "Repeat all steps, up to this point, on the peer node."
msgstr "在对等节点上重复所有步骤，直到现在。"

#. type: Plain text
#: lvm.adoc:423
msgid ""
"Then, edit your `/etc/drbd.conf` to create a new resource named `r0`: "
"indexterm:[drbd.conf]"
msgstr "然后，编辑 `/etc/drbd.conf` 以创建名为 `r0` 的新资源：indexterm:[drbd.conf]"

#. type: delimited block -
#: lvm.adoc:434
#, no-wrap
msgid ""
"resource r0 {\n"
"  device /dev/drbd0;\n"
"  disk /dev/local/r0;\n"
"  meta-disk internal;\n"
"  on <host> { address <address>:<port>; }\n"
"  on <host> { address <address>:<port>; }\n"
"}\n"
msgstr ""
"resource r0 {\n"
"  device /dev/drbd0;\n"
"  disk /dev/local/r0;\n"
"  meta-disk internal;\n"
"  on <host> { address <address>:<port>; }\n"
"  on <host> { address <address>:<port>; }\n"
"}\n"

#. type: Plain text
#: lvm.adoc:438
msgid ""
"After you have created your new resource configuration, be sure to copy your"
" `drbd.conf` contents to the peer node."
msgstr "创建新的资源配置后，请确保将 `drbd.conf` 内容复制到对等节点。"

#. type: Plain text
#: lvm.adoc:442
msgid ""
"After this, initialize your resource as described in <<s-first-time-up>>(on "
"both nodes)."
msgstr "在此之后，按<<s-first-time-up>>中所述初始化资源（在两个节点上）。"

#. type: Plain text
#: lvm.adoc:444
msgid ""
"Then, promote your resource (on one node): indexterm:[drbdadm, primary]"
msgstr "然后，提升资源（在一个节点上）：indexterm:[drbdadm，primary]"

#. type: delimited block -
#: lvm.adoc:447
#, no-wrap
msgid "# drbdadm primary r0\n"
msgstr "# drbdadm primary r0\n"

#. type: Plain text
#: lvm.adoc:451
msgid ""
"Now, on the node where you just promoted your resource, initialize your DRBD"
" device as a new Physical Volume:"
msgstr "现在，在刚刚升级资源的节点上，将DRBD设备初始化为一个新的物理卷："

#. type: Plain text
#: lvm.adoc:454
msgid "indexterm:[LVM]indexterm:[pvcreate (LVM command)]"
msgstr "indexterm:[LVM]indexterm:[pvcreate (LVM command)]"

#. type: delimited block -
#: lvm.adoc:458
#, no-wrap
msgid ""
"# pvcreate /dev/drbd0\n"
"Physical volume \"/dev/drbd0\" successfully created\n"
msgstr ""
"# pvcreate /dev/drbd0\n"
"Physical volume \"/dev/drbd0\" successfully created\n"

#. type: Plain text
#: lvm.adoc:464
msgid ""
"Create your VG named `replicated`, using the PV you just initialized, on the"
" same node: indexterm:[LVM]indexterm:[vgcreate (LVM command)]"
msgstr ""
"使用刚刚初始化的PV在同一节点上创建名为 `replicated` 的VG:indexterm:[LVM]indexterm:[VG "
"Create (LVM command)]"

#. type: delimited block -
#: lvm.adoc:469
#, no-wrap
msgid ""
"# vgcreate replicated /dev/drbd0\n"
"Volume group \"replicated\" successfully created\n"
msgstr ""
"# vgcreate replicated /dev/drbd0\n"
"Volume group \"replicated\" successfully created\n"

#. type: Plain text
#: lvm.adoc:473
msgid ""
"Finally, create your new Logical Volumes within this newly-created VG via "
"indexterm:[LVM]indexterm:[lvcreate (LVM command)]"
msgstr "最后，通过indexterm:[LVM]indexterm:[lvcreate (LVM command)]"

#. type: delimited block -
#: lvm.adoc:480
#, no-wrap
msgid ""
"# lvcreate --name foo --size 4G replicated\n"
"Logical volume \"foo\" created\n"
"# lvcreate --name bar --size 6G replicated\n"
"Logical volume \"bar\" created\n"
msgstr ""
"# lvcreate --name foo --size 4G replicated\n"
"Logical volume \"foo\" created\n"
"# lvcreate --name bar --size 6G replicated\n"
"Logical volume \"bar\" created\n"

#. type: Plain text
#: lvm.adoc:485
msgid ""
"The Logical Volumes `foo` and `bar` will now be available as "
"`/dev/replicated/foo` and `/dev/replicated/bar` on the local node."
msgstr ""
"逻辑卷 `foo` 和 `bar` 现在可以作为本地节点上的 `/dev/replicated/foo` 和 `/dev/replicated/bar` 使用。"

#. type: Title ====
#: lvm.adoc:487
#, no-wrap
msgid "Switching the VG to the other node"
msgstr "将VG切换到另一个节点"

#. type: Plain text
#: lvm.adoc:492
msgid ""
"To make them available on the other node, first issue the following sequence"
" of commands on the primary node: indexterm:[LVM]indexterm:[vgchange (LVM "
"command)]"
msgstr ""
"要使它们在另一个节点上可用，请首先在主节点上发出以下命令序列：indexterm:[LVM]indexterm:[vgchange（LVM "
"command）]"

#. type: delimited block -
#: lvm.adoc:497
#, no-wrap
msgid ""
"# vgchange -a n replicated\n"
"0 logical volume(s) in volume group \"replicated\" now active\n"
"# drbdadm secondary r0\n"
msgstr ""
"# vgchange -a n replicated\n"
"0 logical volume(s) in volume group \"replicated\" now active\n"
"# drbdadm secondary r0\n"

#. type: Plain text
#: lvm.adoc:502
msgid ""
"Then, issue these commands on the other (still secondary) node: "
"indexterm:[drbdadm, primary]indexterm:[LVM]indexterm:[vgchange (LVM "
"command)]"
msgstr ""
"然后，在另一个（仍然是辅助）节点上发出以下命令：indexterm:[drbdadm，primary]indexterm:[LVM]indexterm:[vgchange（LVM命令）]"

#. type: delimited block -
#: lvm.adoc:507
#, no-wrap
msgid ""
"# drbdadm primary r0\n"
"# vgchange -a y replicated\n"
"2 logical volume(s) in volume group \"replicated\" now active\n"
msgstr ""
"# drbdadm primary r0\n"
"# vgchange -a y replicated\n"
"2 logical volume(s) in volume group \"replicated\" now active\n"

#. type: Plain text
#: lvm.adoc:511
msgid ""
"After this, the block devices `/dev/replicated/foo` and "
"`/dev/replicated/bar` will be available on the other (now primary) node."
msgstr "之后，块设备 `/dev/replicated/foo` 和 `/dev/replicated/bar` 将在另一个（现在是主）节点上可用。"

#. type: Title ===
#: lvm.adoc:514
#, no-wrap
msgid "Highly available LVM with Pacemaker"
msgstr "带Pacemaker的高可用LVM"

#. type: Plain text
#: lvm.adoc:519
msgid ""
"The process of transferring volume groups between peers and making the "
"corresponding logical volumes available can be automated. The Pacemaker LVM "
"resource agent is designed for exactly that purpose."
msgstr "在对等机之间传输卷组并使相应的逻辑卷可用的过程可以自动化。PacemakerLVM资源代理正是为此目的而设计的。"

#. type: Plain text
#: lvm.adoc:522
msgid ""
"In order to put an existing, DRBD-backed volume group under Pacemaker "
"management, run the following commands in the `crm` shell:"
msgstr "要将现有的、由DRBD支持的卷组置于Pacemaker管理下，请在 `crm` shell中运行以下命令："

#. type: Block title
#: lvm.adoc:523
#, no-wrap
msgid "Pacemaker configuration for DRBD-backed LVM Volume Group"
msgstr "支持DRBD的LVM卷组的Pacemaker配置"

#. type: delimited block -
#: lvm.adoc:538
#, no-wrap
msgid ""
"primitive p_drbd_r0 ocf:linbit:drbd \\\n"
"  params drbd_resource=\"r0\" \\\n"
"  op monitor interval=\"29s\" role=\"Master\" \\\n"
"  op monitor interval=\"31s\" role=\"Slave\"\n"
"ms ms_drbd_r0 p_drbd_r0 \\\n"
"  meta master-max=\"1\" master-node-max=\"1\" \\\n"
"       clone-max=\"2\" clone-node-max=\"1\" \\\n"
"       notify=\"true\"\n"
"primitive p_lvm_r0 ocf:heartbeat:LVM \\\n"
"  params volgrpname=\"r0\"\n"
"colocation c_lvm_on_drbd inf: p_lvm_r0 ms_drbd_r0:Master\n"
"order o_drbd_before_lvm inf: ms_drbd_r0:promote p_lvm_r0:start\n"
"commit\n"
msgstr ""
"primitive p_drbd_r0 ocf:linbit:drbd \\\n"
"  params drbd_resource=\"r0\" \\\n"
"  op monitor interval=\"29s\" role=\"Master\" \\\n"
"  op monitor interval=\"31s\" role=\"Slave\"\n"
"ms ms_drbd_r0 p_drbd_r0 \\\n"
"  meta master-max=\"1\" master-node-max=\"1\" \\\n"
"       clone-max=\"2\" clone-node-max=\"1\" \\\n"
"       notify=\"true\"\n"
"primitive p_lvm_r0 ocf:heartbeat:LVM \\\n"
"  params volgrpname=\"r0\"\n"
"colocation c_lvm_on_drbd inf: p_lvm_r0 ms_drbd_r0:Master\n"
"order o_drbd_before_lvm inf: ms_drbd_r0:promote p_lvm_r0:start\n"
"commit\n"

#. type: Plain text
#: lvm.adoc:542
msgid ""
"After you have committed this configuration, Pacemaker will automatically "
"make the `r0` volume group available on whichever node currently has the "
"Primary (Master) role for the DRBD resource."
msgstr "提交此配置后，Pacemaker将自动使 `r0` 卷组在当前具有DRBD资源主（Master）角色的节点上可用。"
